/*
Druta.js - contains the main druta class
Druta (meaning, quick/swift/run in Sanskrit, is a runtime that executed abstract instructions on top of JS.
Date: 26 Oct 2012

The objective of Druta is to simplify asynchronous programming that is very common while developing HTML5 applications.

Druta allows a developer to write Javascript code in a synchronous way and executes it on the Javascript runtime on the browser. 
This also can run on server side JS systems like node.js.

Druta has 2 broad sub systems:

(a) Druta Compiler: This takes the input as a JS source function object, parses it to ast, transforms the ast to another tree, generates Druta executable code
(b) Druta Runtime:  This takes the Druta executable code, sequences the different instructions for execution and executes them on JS runtime

This work uses the Uglify JS parser and Tree walker: https://github.com/mishoo/UglifyJS by Mihai Bazon, thanks much Mihai!

Supported Methods:

1. compile(jsSourceFunction) - this methods accepts a function written in JS as input, generates the Druta executable code as output and returns it
2. run(jsSourceFunction) - performs the compile step and also executes
3. run(drutaExecutable) - this method accepts a druta executable code as input generated by the compile step and executes it. 
   It returns 0 if the input is a JS source or an array, otherwise it returns -1
   
Typical usage:

Pattern 1: compile first and then run 
	d = new Druta(pass_your_callback_function_here);
	code = d.compile(function test() { //your druta application code here });
	d.run(code); 
	
Pattern 2: Compile and run in 1 step
	d = new Druta(pass_your_callback_function_here);
	d.run(function test() { //your druta application code here });

  -------------------------------- (C) ---------------------------------

                         Author: Anantharaman Palacode Narayana Iyer
                         <narayana.anantharaman@gmail.com>

  Distributed under the BSD license:

    Copyright 2010 (c) Anantharaman Palacode Narayana Iyer, <narayana.anantharaman@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.
*/
Druta = function(callerContext){
	var self = this;
	this.context = callerContext;
	var DRUTA_EXECUTION_ERROR = -1;
	var BREAK_ERROR = "No enclosing loop for executing break";
	var SUCCESSOBJECT = {code: 0, message:"success"};
	this.returnValue = null;
	
	var runCallBacks = function(cb, e, d) // this routine is expected to take the control back to the caller of Druta
	{
		//self.returnValue = d;
		if (typeof cb == 'function')
		{
			cb(e, d);
			return;
		}
	}	
	/* ******************************************************************************************************************
	 * Compile and Run algorithm
	 * 		1. Get the string form of the code passed to the compiler
	 * 		2. Parse it to get the tree
	 * 		3. Walk the tree to annotate it with async info
	 * 		4. Generate the code lists that can be executed by Druta runtime
	 * 		5. Dispatch the code list to the Druta runtime
	 *******************************************************************************************************************/
	this.compile = function(func)
	{
		var text = String(func);	
		text = text.match(/\s*function\s+.*\(\s*\)\s*{((.|\n)*)}/)[1]; //strip off the wrapper function and just get the body alone
		var code = instrument(text);
		var codeArray;
		codeArray = getDrutaExecutableCode();
		if (codeArray != null) codeArray.unshift(self.context);
		return codeArray;
	}	

	this.run = function (func)
	{
		if (Object.prototype.toString.call(func) === '[object Array]' ) self.dispatch.apply(self, func);
		else if (typeof func == 'function') self.dispatch.apply(self, self.compile(func));	else return -1;			
		//if func is in JS source form, compile and run. Otherwise if it is an array, assume it is Druta code and run it.
		return 0;
	}
	
	this.dispatch = function()
	{
			var TOPLEVEL = 0;
			var FORSTMT = 1;
			var IFSTMT = 2;			
			//states
			var INITIAL = 0;
			var FOR_COND = 1;
			var FOR_BODY = 2;
			var FOR_STEPS = 3;
			var STATE_BREAK = 4;
			var STATE_CONTINUE = 5;
			
			var currentSequence;
			var currentEnclosingLoop = []; //variable to hold the reference to a loop statement that is currently executing, needed for break/continue
			var sequenceStack = [];			
  			var args = [].splice.call(arguments,0); //convert the arguments to an array object and save in args 
  			var syncInstruction = true;
			var context = args[0]; //arguments[0];
			var $$locals = {}; // an object to store local variables

			var $$fail = function(e)
			{
  				self.returnValue = null;
				runCallBacks(context, e, null);
			}			
			var $$callBack = function(e, v)
			{
				if (e.code == SUCCESSOBJECT.code) $$success(v); 
				else $$fail(e);
			}
  			var $$success = function(value) {
					self.returnValue = value;					
					if (stmts.length == currentSequence.index) //nothing more available in argument array, all functions executed and so return
  					{
						if(sequenceStack.length > 0) //if the stack not empty
						{
							currentSequence = sequenceStack.pop();
							stmts = currentSequence.statements;	
						}
						else
						{
  							runCallBacks(context, SUCCESSOBJECT, value);
							return;  							
						}
  					}  		
  					syncInstruction = true;
  					var stmt;
					while ((sequenceStack.length > 0) && syncInstruction) {
						while (currentSequence.index < stmts.length) //this loop will keep executing instruction blocks till it encounters a function
						{
							stmt = stmts[currentSequence.index++]; //statement from the statement list
							if (!stmt.async) //if (!__DrutaAsync) //if this is an instruction block just evaluate it
							{
								if (stmt.command == "if") {
									sequenceStack.push(currentSequence); //this will be poped after all the instructions are executed in then or else block
									if (eval(stmt.condCode)) {
										currentSequence = {
											"command": stmt.command,
											"type": IFSTMT,
											"statements": stmt.thenCode,
											"index": 0
										};
										stmts = stmt.thenCode;
										//console.log(stmts);										
									}
									else {
										currentSequence = {
											"command": stmt.command,
											"type": IFSTMT,
											"statements": stmt.elseCode,
											"index": 0
										};
										stmts = stmt.elseCode;
									}
									syncInstruction = true;
									continue;
								}
								else if (stmt.command == "for") {
									sequenceStack.push(currentSequence); //this will be poped after all the instructions are executed in then or else block
									currentSequence = {
										"command": stmt.command, "type": FORSTMT, "statements": stmt.condCode, 
										"structure": [stmt.condCode, stmt.bodyCode, stmt.stepCode], "index": 0, state: FOR_COND
									};
									currentEnclosingLoop.push(currentSequence);
									stmts = stmt.condCode;
									syncInstruction = true;
									continue;
								}
								else if (stmt.command == "break") {
									//need to discard executing the remaining instructions from the loop and set the state to INITIAL
									syncInstruction = true;
									if (currentEnclosingLoop.length > 0) currentEnclosingLoop[currentEnclosingLoop.length - 1].state = STATE_BREAK;
									else {
										$$fail(DRUTA_EXECUTION_ERROR, BREAK_ERROR);
										return;
									}
									currentSequence.index = stmts.length; //discard the remaining statements in the array by making the size to 0
									while((currentSequence.command != currentEnclosingLoop[currentEnclosingLoop.length - 1].command) && (sequenceStack.length > 0))
									{
										currentSequence = sequenceStack.pop();
									}
									if (sequenceStack.length == 0) {
										$$fail(DRUTA_EXECUTION_ERROR, BREAK_ERROR);
										return;
									};
									break; //continue;
								}
								else if (stmt.command == "continue") {
									//need to discard executing the remaining instructions from the loop and set the state to INITIAL
									syncInstruction = true;
									if (currentEnclosingLoop.length > 0) currentEnclosingLoop[currentEnclosingLoop.length - 1].state = STATE_CONTINUE;
									else {
										$$fail(DRUTA_EXECUTION_ERROR, BREAK_ERROR);
										return;
									}
									currentSequence.index = stmts.length; //discard the remaining statements in the array by making the size to 0
									while((currentSequence.command != currentEnclosingLoop[currentEnclosingLoop.length - 1].command) && (sequenceStack.length > 0))
									{
										currentSequence = sequenceStack.pop();
									}
									break; //continue;
								};
								
								self.returnValue = eval(stmt.code);
								syncInstruction = true;
								continue;
							}
							else //async call instruction
							{
								syncInstruction = false; //__DrutaAsync = false;
								break;
							}
						} //while end
						//control comes here when the block is executed or there is an async instruction - if syncInstruction
						if (!syncInstruction) break;
						//currentSequence = sequenceStack.pop();
						if (currentSequence.type == FORSTMT) {
								switch (currentSequence.state) {
									case STATE_BREAK:
										currentSequence.state = INITIAL;
										currentSequence = sequenceStack.pop();
										stmts = currentSequence.statements;
										currentEnclosingLoop.pop();
										break;
									case FOR_COND:
										if (self.returnValue) {
											currentSequence.state = FOR_BODY;
											currentSequence.statements = currentSequence.structure[1];
											currentSequence.index = 0;
										}
										else {
											currentSequence.state = INITIAL;
											currentSequence = sequenceStack.pop();
											stmts = currentSequence.statements;
											currentEnclosingLoop.pop();
										}
										break;
									case FOR_BODY:
									case STATE_CONTINUE:
										currentSequence.state = FOR_STEPS;
										currentSequence.index = 0;
										currentSequence.statements = currentSequence.structure[2];
										break;
									case FOR_STEPS:
										currentSequence.state = FOR_COND;
										currentSequence.index = 0;
										currentSequence.statements = currentSequence.structure[0];
										break;
								}
						}
						else {
							currentSequence = sequenceStack.pop();
						}
						stmts = currentSequence.statements;
					} //outer while
  				
					if ((syncInstruction) && (currentSequence.index == stmts.length))
					{
 						runCallBacks(context, SUCCESSOBJECT, self.returnValue);
						return;  
					}		 	 		
					self.returnValue = eval(stmt.code);
  					return;  	
  			}; //$$success1
			currentSequence = {"type": TOPLEVEL, "statements": args, "index":1};
			stmts = currentSequence.statements;
			sequenceStack.push(currentSequence);
  			$$success();
	} //dispatch	
} //Druta